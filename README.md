eg1 说出下列执行结果
var a = []
for (var i = 0; i < 10; i++) {
    a[i] = function () {
        console.log(i)
    }
}
a[6]()
 在执行a[]()函数for循环已经执行结束,此时i结果是10,不管a[]()数组第几项执行结果都是10

 eg2 执行结果并解释
  var temp = 123
  if (true) {
      console.log(temp)
      let temp
  }
  会报错在函数作用域let声明的变量不允许声明之前访问

 eg3 用es6语法找出数组最小值
var arr = [12, 34, 32, 89, 4]
arr.sort((a, b) => {
    return a - b
})
console.log(arr[0])

 eg4 var,let,const区别
 var声明的变量会发生变量提升,
 let声明的变量只在当前作用域内被访问,不会发生变量提升,不能再声明之前被访问
 const声明的变量是只读的且不可修改,但是const声明的对象是可以修改内部属性的

 eg5 说出结果并说明理由
var a = 10
var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
            console.log(this.a);
        });
    }
}
 obj.fn()  20
  obj.fn()得知fn中的this指向obj
  在箭头函数中引用this实际上指向上一层作用域的this(fn),fn的this指向obj,所以这里的this指向obj

  eg6 Symbol类型的用途
  由于每一个Symbol的值都是不相等的,所以Symbol作为对象的属性名,可以保证属性不重名
  读取到一个对象的Symbol属性,可以通过 Object.getOwnPropertySymbols()和Reflect.ownKeys()取到
  使用 Symbol定义常量,这样就可以保证这一组常量的值都不相等

 eg7 深浅拷贝
  浅拷贝
  1 浅拷贝是创建一个新对象,这个对象有着原始对象属性值的一份精确拷贝。
  2 如果属性是基本类型,拷贝的就是基本类型的值,如果属性是引用类型,拷贝的就是内存地址,所以如果其中一个对象改变了这个地址,就会影响到另一个对象
  深拷贝
  深拷贝是将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

 eg8 简述TypeScript和JavaScript关系
 TypeScript是JavaScript的超集,TypeScript可以使用JavaScript中的所有代码和编码概念,TypeScript是为了使JavaScript的开发变得更加容易而创建的

 eg9 TypeScript优缺点
  优点:
  (1)增强代码的可读性和可维护性,强类型的系统相当于最好的文档,在编译时即可发现大部分的错误,增强编辑器的功能。
  (2)包容性,js文件可以直接改成ts文件,不定义类型可自动推论类型,可以定义几乎一切类型,ts编译报错时也可以生成js文件,兼容第三方库,即使不是用ts编写的
  (3)有活跃的社区,大多数的第三方库都可提供给ts的类型定义文件,完全支持es6规范
  缺点:
  (1)增加学习成本,需要理解接口（Interfaces）和泛型（Generics）,类（class）,枚举类型（Enums）
  (2)短期增加开发成本,增加类型定义,但减少维护成本
  (3)ts集成到构建流程需要一定的工作量
  (4)和有些库结合时不是很完美

eg10 引用计数原理优缺点
优点:发现垃圾立即回收,最大限度减少程序暂停
缺点:无法回收循环引用的对象,时间消耗大

eg11 描述标记整理算法工作流程
1.标记整理可以看成标记清除的增强
2.标记阶段的操作和标记清除一致
3.清除阶段会执行整理移动对象位置

eg12 描述v8新生代存储区垃圾回收流程
1.回收过程采用复制算法和标记整理
2.新生代内存分为大小等大的两个内存
3.使用空间from,空闲空间to
4.活动对象存属于from空间
5.标记整理后将活动对象拷贝至to
6.from与to交换空间完成释放

eg13 描述增量标记算法在何时使用及工作原理
标记增量算法在老生代垃圾回收使用
为了降低全堆垃圾回收带来的停顿时间,V8先从标记阶段入手,将原本要一口气停顿完成的动作改成增量标记(Incremental Marking)
也就是拆分为许多小“步进”,每做完一“步进”就让JavaScript应用逻辑执行一小会儿,垃圾回收和应用逻辑交替执行直到标记阶段完成
增量标记允许堆的标记发生在几次5-10毫秒（移动设备）的小停顿中。增量标记在堆的大小达到一定的阈值时启用
启用之后每当一定量的内存分配后,脚本的执行就会停顿并进行一次增量标记。就像普通的标记一样,增量标记也是一个深度优先搜索,并同样采用白灰黑机制来分类对象。